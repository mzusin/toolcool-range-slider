/* 
Tool Cool Range Slider - Fire Plugin
Version: 1.0.0
Documentation: https://github.com/toolcool-org/toolcool-range-slider 
License: MIT License        
Author: Tool Cool, toolcool.org@gmail.com>                          
*/
(()=>{var V=e=>!isNaN(parseFloat(e))&&isFinite(e),s=(e,o)=>V(e)?Number(e):o;var I=e=>e==null?!1:typeof e=="boolean"?e:e.trim().toLowerCase()==="true";var z=(e,o,r)=>{let i=document.createElement("canvas");return i.classList.add("fire-canvas"),i.width=o,i.height=r,i.style.width=`${o}px`,i.style.height=`${r}px`,e.prepend(i),i};var M=e=>{let o=e.getContext("webgl")||e.getContext("experimental-webgl");return o||console.error("This browser doesn't support WebGL."),o},w=(e,o,r)=>{let i=e.createShader(o);return i?(e.shaderSource(i,r),e.compileShader(i),e.getShaderParameter(i,e.COMPILE_STATUS)?i:(console.error(`Error compiling shader: ${e.getShaderInfoLog(i)}`),null)):null},U=(e,o)=>{let r=e.createProgram();if(!r)return null;for(let i=0;i<o.length;i++)e.attachShader(r,o[i]);return e.linkProgram(r),e.getProgramParameter(r,e.LINK_STATUS)?(e.validateProgram(r),r):(console.error(`Error linking program: ${e.getProgramInfoLog(r)}`),null)},G=(e,o,r,i,f,l,t)=>{let p=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,p),t&&e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW);let c=e.getAttribLocation(o,r);return e.vertexAttribPointer(c,i,e.FLOAT,!1,f*Float32Array.BYTES_PER_ELEMENT,l*Float32Array.BYTES_PER_ELEMENT),e.enableVertexAttribArray(c),c};var _=`attribute vec2 aPosition;

void main(void){
    gl_Position = vec4(aPosition, 0.0, 1.0);
}`;var H=`// \xA9 JSOcean, https://codecanyon.net/licenses
// https://codecanyon.net/user/js-ocean/portfolio

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 uResolution;
uniform float uTime;
uniform float uRunning;

uniform vec3 uBaseColor1;
uniform vec3 uBaseColor2;
uniform float uFireShape;
uniform float uSpeed;
uniform float uFireStrength;
uniform float uFireDetalization;

#define NUM_OCTAVES 5

/**
 * get random number
 */
float random(vec2 uv) {
    return fract(sin(uv.x * 113.0 + uv.y * 412.0) * 6339.0);
}

/**
 * perlin noise 
 */
float perlin(vec2 uv) {
    vec2 i = floor(uv);
    vec2 f = fract(uv);
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    // mix 4 coorners percentages
    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}


/**
 * fractal brownian motion - fractal noise
 * https://en.wikipedia.org/wiki/Fractional_Brownian_motion
 * FMB always gives a number between [0, 1]
 */
float fbm (in vec2 position){

    float f = 0.0;

    // the rotation transformation and the magnification transformation are multiplied -> expansion transformation
    mat2 m = mat2(1.6,  1.2, -1.2,  1.6);

    f  = 0.5000 * perlin(position);
    position = m * position;

    f += 0.2500 * perlin(position);
    position = m * position;

    f += 0.1250 * perlin(position);
    position = m * position;

    f += 0.0625 * perlin(position);
    position = m * position;

    return f;
}

/**
 * bump noise
 */
vec3 bumpMap(vec2 uv, float normalStrength) {
    vec2 s = 1.0 / uResolution.xy;
    float p =  fbm(uv);
    float h1 = fbm(uv + s * vec2(1.0, 0) * uFireShape);
    float v1 = fbm(uv + s * vec2(0.0, 1.0));
    vec2 xy = (p - vec2(h1, v1)) * normalStrength;
    return vec3(xy + 0.5, 1.0);
}

/**
 * create a circle
 */
float drawCircle(vec2 uv, float radius, float smoothThickness){
    return smoothstep(radius - smoothThickness, radius + smoothThickness, length(uv));
}

/**
 * generate a fire that consists of 3 flames
 */
vec3 fire(vec2 uv, float detalization, vec2 direction, float fireStrength, float radius, float soft) {

    vec3 color = vec3(0.0);

    // define the bump map
    uv += clamp((bumpMap(detalization * uv + direction, fireStrength).xy - 0.5), -1.0, 1.0);
    
    // invert the color
    color += 1.0 - drawCircle(uv, radius, soft);

    uv += clamp((bumpMap(detalization * 1.1 * uv + direction, fireStrength).xy - 0.5), -1.0, 1.0);
    
    // invert the color
    color += 1.0 - drawCircle(uv, radius / 2.0, soft);
    
    return color;
}

/**
 * entry point
 */
void main() {

    float time = uTime * uRunning;

    // normalize coordinates and fix aspect ratio
    vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution.xy) / min(uResolution.x, uResolution.y);
    uv.y += 0.5;

    vec3 color = vec3(0.0);

    // generate horizontal fire layer
    for(float i=-1.0; i <= 1.0; i+= 0.4){
        color += fire(uv - vec2(i, 0.1), uFireDetalization, -vec2(i * 12.0, time * (uSpeed - i / 10.0)), uFireStrength, 0.2, 0.05);
    }
    
    // set fire color
    vec3 gradient = mix(uBaseColor1, uBaseColor2, uv.y);
    color = mix(vec3(0.0), gradient, color);
    
    gl_FragColor = vec4(color, 1.0);

}`;var D=(e,o)=>{let r,i=!0,f=!1,l=z(e,o.fireWidth,o.fireHeight);if(!l)return null;let t=M(l);if(!t)return null;t.viewport(0,0,t.canvas.width,t.canvas.height);let p=w(t,t.VERTEX_SHADER,_);if(!p)return null;let c=w(t,t.FRAGMENT_SHADER,H);if(!c)return null;let a=U(t,[p,c]);if(!a)return null;t.useProgram(a);let x=new Float32Array([-1,-1,1,1,1,-1,-1,-1,1,1,-1,1]);G(t,a,"aPosition",2,0,0,x);let F=t.getUniformLocation(a,"uResolution");t.uniform2fv(F,new Float32Array([t.drawingBufferWidth,t.drawingBufferHeight]));let y=t.getUniformLocation(a,"uTime"),A=t.getUniformLocation(a,"uRunning"),h=t.getUniformLocation(a,"uBaseColor1");t.uniform3fv(h,new Float32Array(o.fireBaseColor1));let v=t.getUniformLocation(a,"uBaseColor2");t.uniform3fv(v,new Float32Array(o.fireBaseColor2));let C=t.getUniformLocation(a,"uFireShape");t.uniform1f(C,o.fireShape);let b=t.getUniformLocation(a,"uSpeed");t.uniform1f(b,o.fireSpeed);let E=t.getUniformLocation(a,"uFireStrength");t.uniform1f(E,o.fireStrength);let T=t.getUniformLocation(a,"uFireDetalization");t.uniform1f(T,o.fireDetalization);let R=n=>{if(n!==void 0&&!f){r===void 0&&(r=n);let u=(n-r)/1e3;t.clear(t.COLOR_BUFFER_BIT),t.useProgram(a),t.uniform1f(y,n/1e3),t.uniform1f(A,i?1:0),t.drawArrays(t.TRIANGLES,0,6),u>10*60&&(r=void 0),requestAnimationFrame(R)}};return requestAnimationFrame(R),{$canvas:l,setColors:(n,u)=>{t.uniform3fv(h,new Float32Array(n)),t.uniform3fv(v,new Float32Array(u))}}};var S=e=>{let o=/^#?([a-f\d])([a-f\d])([a-f\d])$/i;e=e.replace(o,(i,f,l,t)=>f+f+l+l+t+t);let r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return r?[parseInt(r[1],16)/255,parseInt(r[2],16)/255,parseInt(r[3],16)/255]:[]};window.tcRangeSliderPlugins=window.tcRangeSliderPlugins||[];var N="#000",W="#bc4c18",k="#fff200",O=55,Y=150,q=()=>{let e=null,o=null,r=null,i=!1,f=N,l=W,t=k,p=1,c=O,a=Y,x=.4,F=.6,y=90,A=110,h=.5,v=1,C=[],b=(n,u)=>Math.random()*(u-n)+n,E=n=>{if(!i)return;let u=(r==null?void 0:r.getPercents())||[];for(let m=0;m<u.length;m++){let g=C[m];if(!g)continue;g.$canvas.style.left=`${u[m]}%`;let d=S(l),L=S(t);d[0]=u[m]/100,g.setColors(d,L)}},T=()=>{!e||(e.style.background=f)},R=()=>{if(!r||!o)return;let n=r.getPercents()||[];for(let u=0;u<n.length;u++){let m=S(l),g=S(t);m[0]=n[u]/100,g[0]=n[u]/100;let d=D(o,{fireBaseColor1:m,fireBaseColor2:g,fireShape:p,fireSpeed:b(x,F),fireStrength:b(y,A),fireDetalization:b(h,v),fireWidth:c,fireHeight:a});d&&(d.$canvas.style.left=`${n[u]}%`),C.push(d)}};return{get name(){return"Fire"},init:(n,u,m,g)=>{var d,L,P,B;r=g,e=n,i=I(n.getAttribute("fire")),i&&(f=(d=n.getAttribute("fire-bg"))!=null?d:N,l=(L=n.getAttribute("fire-color1"))!=null?L:W,t=(P=n.getAttribute("fire-color2"))!=null?P:k,p=s(n.getAttribute("fire-shape"),1),x=s(n.getAttribute("fire-speed-start"),.4),F=s(n.getAttribute("fire-speed-end"),.6),y=s(n.getAttribute("fire-strength-start"),90),A=s(n.getAttribute("fire-strength-end"),110),c=s(n.getAttribute("fire-width"),O),a=s(n.getAttribute("fire-height"),Y),h=s(n.getAttribute("fire-detalization-start"),1),v=s(n.getAttribute("fire-detalization-end"),1),o=(B=n.shadowRoot)==null?void 0:B.querySelector(".container"),o&&(T(),R()))},update:E,css:`
.range-slider-box{
  display: flex;
  flex-direction: column;
  justify-content: center;
}   

.fire-canvas{
  width: 35px;
  height: 50px;
  position: absolute;
  top: 0;
  left: 0;
  transform: translateY(-100%) translateX(-50%);
  overflow: hidden;
  clip-path: ellipse(25% 40% at 50% 50%);
  pointer-events: none;
} 

.animate-on-click .fire-canvas{
    transition: all var(--animate-onclick);
}
    `}};window.tcRangeSliderPlugins.push(q);var me=q;})();
